https://msdn.microsoft.com/en-us/library/ms256184(v=vs.110).aspx
http://lenzconsulting.com/how-xslt-works/

we can use the <xsl:template match="..."> only, or we can use it with <xsl:apply-templates>
the <xsl:apply-templates> is not necessary at all. 
If <xsl:template match="/"> is defined, this is the entry point of the whole process.

Regardless of what your stylesheet contains, XSLT processing always begins with a virtual call to: call to <xsl:apply-templates select="/"/> . 
https://stackoverflow.com/questions/1531664/in-what-order-do-templates-in-an-xslt-document-execute-and-do-they-match-on-the

This virtual call constructs the entire result tree, which, after all, is the point of executing a stylesheet.
http://lenzconsulting.com/how-xslt-works/

the <xsl:apply-templates> should put inside of <xsl:template match="...">.

The <xsl:apply-templates> element first selects a set of nodes using the expression specified in the select attribute.
If this attribute is left unspecified, it is:
	<xsl:apply-templates select="node()"/>
all children of the current node are selected.
(note, the select attribute is to select nodes, not for 'matching' template name attribute)
(if the node is not selected, then no action will do on it)
the <apply-templates> element illustrates the recursive nature of XSLT processing.
the recursion continues as long as the xsl:apply-templates instruction appears inside an instantiated template rule and is given a non-empty list of nodes to process. 
This process continues until there are no more nodes to process. 
At that point, the entire result tree has been constructed.

the select attribute applies templates to the child nodes of the current node. 
In other words, it populates the current node list with the set of nodes returned by the select expression, and it iterates over them in document order, invoking the best-matching template rule for each node.

It is possible to make xsl:apply-templates iterate over a node-set in an order other than document order. (xsl:sort)

For each of the selected nodes, <xsl:apply-templates> directs the XSLT processor to find an appropriate <xsl:template> to apply.

The value of the match attribute of <xsl:apply-templates> is an XSLT pattern. 
Unlike an XPath expression, a pattern is not concerned with selecting a set of nodes from a given context.
Instead, it has a more passive role. The template rule effectively announces “I know how to process xxx elements.”
The allowed syntax for a pattern is a subset of the allowed syntax for XPath expressions.

A node matches a pattern if the node is a member of the result of evaluating the pattern as an expression with respect to some possible context node.

Because patterns allow only downward-looking axes (child, attribute, and //), 
the “possible context node” will always be one of the node's ancestors (or the node itself in the case of the pattern “/”).

Templates are tested for applicability by comparing the node to the XPath expression specified in the template's match attribute.
If more than one template satisfies the match pattern, the one appearing with the highest priority is chosen.
If several templates have the same priority, the last in the style sheet is chosen.

If multiple templates can match a node, the one with the more specific match expression wins. (pattern 'foo' higher than '*')
If more than one matching template with the same specificity exist, the one declared last wins.
(https://stackoverflow.com/questions/4478045/what-are-the-differences-between-call-template-and-apply-templates-in-xsl)

Also, template rules in an imported stylesheet have lower import precedence than template rules in the importing stylesheet.

Thus, there are two steps in this process of elimination:
	1. The XSLT processor eliminates rules with lower import precedence. (exception:  “xsl:apply-imports”)
	2. Among the remaining template rules, the XSLT processor eliminates the rules with lower priority.
It is an error if there is more than one template rule left. 
If that happens, the XSLT processor can either signal the error or recover by invoking the matching template rule that occurs last in the stylesheet. 
Most processors will at least give a warning if this happens.

A template rule can explicitly specify its priority using the optional priority attribute on the xsl:template element.

<xsl:apply-templates mode="foo"/>
<xsl:template match="*" mode="foo">
when mode is used in apply-template, only the template with the same mode is selected.
If you leave the mode attribute off of xsl:apply-templates, then only the template rules that have no mode attribute will be considered.


(if no template found for the selected nodes, then this nodes is not considered)
(the above statement is not correct, if no template found for the selected nodes, the "built-in template" rule apply)

if no <xsl:template match="..."> matching for the <xsl:apply-templates select="...">, then the built-in rule will works.
XSLT defines a built-in template rule for each of the seven types of node.

Built-in rule for element nodes and the root node are:
    <xsl:template match="/|*">
        <xsl:apply-templates/>
    </xsl:template>


Built-in rule for text and attribute:
	<xsl:template match="text()|@*">
		<xsl:value-of select="."/>
	</xsl:template>
	
other rule can be found on the last part of this doc.


The content of the xsl:template element (following zero or more optional xsl:param elements) is a “template” for constructing part of the result tree. 
This “template” can contain both elements and text. 
Elements in the XSLT namespace are called instructions, elements in an extension namespace are called extension elements, and elements in any other namespace (or no namespace) are called literal result elements.

A text node acts as an instruction to create a corresponding text node in the result tree. 
In other words, text nodes in the stylesheet are copied to the result tree automatically.

Attributes on literal result elements are interpreted as attribute value templates (AVTs). 
This means that you can use curly braces ({...}) to insert a dynamically computed value into the attribute value. 
The curly braces within the attribute delimit an XPath expression evaluated in the current XSLT context.

In addition to the attributes of literal result elements, some attributes of elements in the XSLT namespace are interpreted as AVTs.
In other words, the curly braces ({...}) have the special meaning. 
In either case, if you want to include an actual brace character in the resulting attribute value, you can escape it by repeating the brace. 
In an AVT context, {{ is the escape sequence for {, and }} is the escape sequence for }.


All XPath expressions are evaluated in a context. The current node and current node list supply an important part of that context
the xsl:for-each changes the current node and current node list.

Whitespace-only text nodes in an XSLT stylesheet are considered insignificant and are stripped from the stylesheet tree before XSLT processing begins—except when they occur inside xsl:text elements or elements with the declaration xml:space="preserve". 

Whitespace stripping is also an optional process that can be applied to the source tree before XSLT processing begins. 
By default, unlike the stylesheet tree, all whitespace is preserved in the source tree.

XSLT processing is primarily concerned with constructing a result tree. 
Serialization involves converting that result tree to an actual XML stream or file. 
The xsl:output element is a top-level element that lets you give hints to the XSLT processor about how you want your result tree to be serialized. 
Technically, the XSLT processor is not required to heed the hints you give it (or even to serialize the result tree at all), but if it does heed your hints, it must follow the rules for interpreting the xsl:output element.



Note, 2 kind of tag:
<xsl:apply-templates select="title"/>
<xsl:template match="cd">

Please note:
<xsl:template match="/catalog/">
<xsl:template match="/catalog/*">
<xsl:template match="/catalog">
are different

<xsl:template match="/catalog/"> == <xsl:template match="/catalog/node()">
it seems that you can't using <xsl:template match="/catalog/"> in this example.


compare:
    <xsl:template match="/catalog">
        <html>
            <body>
                <h2>My CD Collection</h2>
                <xsl:apply-templates/>
            </body>
        </html>
    </xsl:template>

with:
    <xsl:template match="/catalog">
        <html>
            <body>
                <h2>My CD Collection</h2>
                <xsl:apply-templates select="cd"/>
            </body>
        </html>
    </xsl:template>



modify to:
    <xsl:template match="/">
        <html>
            <body>
                <h2>My CD Collection</h2>
                <!--<xsl:apply-templates/>-->
            </body>
        </html>
    </xsl:template>
it means, when there is a template match "root", the other template will not be considered.


comment out:
    <xsl:template match="/">
        <html>
            <body>
                <h2>My CD Collection</h2>
                <xsl:apply-templates/>
            </body>
        </html>
    </xsl:template>

the built-in rules apply.



modify to:
    <xsl:template match="/">
        <html>
            <body>
                <h2>My CD Collection</h2>
                <xsl:apply-templates select="title"/>
                <!--<xsl:apply-templates/>-->
            </body>
        </html>
    </xsl:template>
it means, it only try to select nodes from first child level of matching element, in this case, no nodes are selected.


Test 1:
remove following:
    <xsl:template match="cd">
        <p>
            <xsl:apply-templates select="title"/>
            <xsl:apply-templates select="artist"/>
        </p>
    </xsl:template>

    <xsl:template match="title">
        Title: <span style="color:#ff0000">
        <xsl:value-of select="."/></span>
        <br />
    </xsl:template>

    <xsl:template match="artist">
        Artist: <span style="color:#00ff00">
        <xsl:value-of select="."/></span>
        <br />
    </xsl:template>

it seems without corresponding template, it just print the content of the element.(built-in rules)

Test 2:
change to: <xsl:template match="/catalog">
same as before.

Test 2-2:
change to: <xsl:template match="/catalog123">
why?
in this case, this <xsl:template match="/catalog123"> can't find match node, so it is not used.
then, it will go through the process described at the end of this note.txt.

Test 2-3:
change to:
    <xsl:template match="/catalog/cd">
        <html>
            <body>
                <h2>My CD Collection</h2>
                <xsl:apply-templates select="country"/>
            </body>
        </html>
    </xsl:template>

it seems, for the not selected part, "I am here.", "cd2", it will go through the process described at the bottom of this note.txt.
(it means if you don't define template for root, you should define template for all of its child node, otherwise, it will go through the process)
Please note the pring position for "I am here.", "cd2".
the reason why is because <xsl:template match="/catalog/cd"> is for /catalog/cd, is not from root, the process is looking for 
<xsl:template match="/"> as entry point, if it don't have, it will go through the process.

for the selected part, if it can't find the matching template, it don't do any thing.
(for the selected part, if only parts of its node operated, the other node don't go through the process)

Test 3:
change to: <xsl:template match="/catalog/">
error.

Test 4:
change to: <xsl:template match="/catalog/*">
in this case, the <html> repeat 2 times.
you can remove:
    <xsl:template match="cd">
        <p>
            <xsl:apply-templates select="title"/>
            <xsl:apply-templates select="artist"/>
        </p>
    </xsl:template>
in this test case, because it doesn't selected.

Test 5:
change to: <xsl:template match="/catalog/node()">
You can see, for every node between elements, it print something.
following have 5 node under <catalog>
<catalog>
    <cd>...</cd>
    <cd>...</cd>
</catalog>

change to:
<catalog><cd>...</cd><cd>...</cd></catalog>
only 2 node.

Test 5:
in above test case, change to:
<xsl:template match="catalog/cd">

in this case, you can remove following part:
    <xsl:template match="/catalog/node()">
        <html>
            <body>
                <h2>My CD Collection</h2>
                <xsl:apply-templates/>
            </body>
        </html>
    </xsl:template>
you can see the difference, it shows in this case, both
<xsl:template match="/catalog/node()">
and
<xsl:template match="catalog/cd">
take effect.

you can switch the order of these 2 element, to see the meaning of:
"If several templates have the same priority, the last in the style sheet is chosen."

actually, the <xsl:apply-templates/> is not necessary, you can use <xsl:template match="/"> to trigger the process.
using <xsl:apply-templates/> is a way to specify the entry point, and you can have something around this entry point.
Without it, you need to put these "something" inside of the root template.
(the above statement is not correct, the entry point is <xsl:template match="/">, the <xsl:apply-templates/> is in this tag.
you can try, if <xsl:apply-templates/> is not within any <xsl:template match="...">, it not working.

if you don't have <xsl:apply-templates/>, or you have it but it not used.
I guess it will try from root node, it will try to find out template <xsl:template match="/">, if you don't have it.
it will try first layer under root node, list every node, for each node, it will try to find out the matching template.
if it find out the template, it will using this template, and not go deeper for this node.
if it can't find out the template for this node, it will loop the node list under this node, try to find out the matching template.
go through this process until it find out the content of the end node, then it just print out the content.


built-in template rule:
https://msdn.microsoft.com/en-us/library/ms764653(v=vs.85).aspx
https://docstore.mik.ua/orelly/xml/xmlnut/ch08_07.htm
